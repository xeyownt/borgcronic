#! /bin/bash

# Common settings
BASE=borgcronic
LOGFILE=/var/log/$BASE
CONF=/etc/$BASE.conf
LOGROTATE=/etc/logrotate.d/$BASE
LOCKDIR=/var/lock/$BASE
PIDFILE=/var/lock/$BASE/pid
TRY_WAIT=120               # (seconds) Delay to wait before trying again

# Borg environment variables (see https://borgbackup.readthedocs.io/en/stable/usage.html)
export BORG_CACHE_DIR=/var/cache/borg
export BORG_KEYS_DIR=/var/lib/borg/keys
export BORG_SECURITY_DIR=/var/lib/borg/security
BORG_LASTSUCCESSFUL=$BORG_CACHE_DIR/$BASE.success

die()
{
    CODE=$1
    shift
    >&2 echo "ERROR -- $@"
    exit $CODE
}

sizeof()
{
    du -sB1 "$@" | awk '{s+=$1} END {printf "%dM (%d)",s/(2**20),s}'
}

install_logrotate()
{
    [ -e $LOGROTATE ] && return

    if [ -d $(dirname $LOGROTATE) ]; then
        >&2 echo "Installing logrotate file '$LOGROTATE'."
        cat > $LOGROTATE <<- __END__
/var/log/$BASE
{
    rotate 4
    weekly
    missingok
    notifempty
    compress
    delaycompress
}
__END__
        chmod 644 $LOGROTATE
    else
        >&2 echo "WARNING - $(dirname $LOGROTATE) not found. Can't install logrotate script."
    fi
}

install_conf()
{
    [ -e $CONF ] && return

    >&2 echo "Installing config file '$CONF'."
    cat > $CONF <<- __END__
## REPOSITORY - mandatory
#REPOSITORY=username@remoteserver.com:backup

## DIRS - mandatory
DIRS='/home'

## EXCLUDES - optional
EXCLUDES='--exclude */.cache'
EXCLUDES+=' --exclude *.nobak'
EXCLUDES+=' --exclude */xapiandb'
EXCLUDES+=' --exclude */.thumbnails'
__END__
    chmod 644 $CONF
}

check_or_do_install()
{
    # Create logrotate script and config if requested
    if [ -n "$INSTALL_REQ" ]; then
        install_logrotate
        install_conf
        exit 0
    fi

    [ -e $LOGROTATE ] && [ -e $CONF ] && return
    die 1 "'$LOGROTATE' or '$CONF' missing. Please first run '$BASE -i' to run install procedure."
}

print_size_summary()
{
    echo "## Borg repo: $(sizeof $REPOSITORY)"
    echo "## Borg cache: $(sizeof $BORG_CACHE_DIR)"
}

check_root()
{
    [ $(whoami) == "root" ] || die 1 "Run this script as root or sudo"
}

read_conf()
{
    REPOSITORY=
    DIRS=
    EXCLUDES=
    [ -e $CONF ] || die 1 "'$CONF' not found."
    . $CONF
}

check_conf()
{
    [ -n "$REPOSITORY" ] || die 1 "REPOSITORY not defined or empty."
    [ -n "$DIRS" ]       || die 1 "DIRS not defined or empty."
    [ -d "$REPOSITORY" ] || die 1 "'$REPOSITORY' not found."
}

read_options()
{
    # Parse options
    BORG=borg
    BG="&"
    VERBOSE=0
    DIRS_STAT=
    INSTALL_REQ=

    while getopts "dfisv" flag; do
        case "$flag" in
            d)
                # dry-run mode
                BORG="echo $BORG" ;;
            f)
                # run in foreground
                BG= ;;
            i)
                # install request
                INSTALL_REQ=true ;;
            s)
                # Display DIRS statistics
                DIRS_STAT=true ;;
            v)
                # Verbose mode
                VERBOSE=$((VERBOSE+1)) ;;
            *)
                echo "Usage: $BASE.sh [-dfisv]"
                exit 1
                ;;
        esac
    done
    shift $((OPTIND-1))
}

print_log_header()
{
    echo "####################################################################################################"
    echo "# $(date) -- Start $BASE[$$]"
}

print_log_footer()
{
    echo "# $(date) -- End $BASE[$$]"
}

syslog()
{
    logger --id=$$ -t $BASE "$@"
    echo "# $(date) -- $@"
}

doit()
{
    echo "# $(date) ## $@"
    print_size_summary
    echo "===================================================================================================="
    "$@"
    echo "===================================================================================================="
    print_size_summary
    # We must return exit status of "$@" !
}

print_dirs_stats()
{
    if [ -n "$DIRS_STAT" ]; then
        DIRS_SZ=$(sizeof $DIRS)
        DIRS_ND=$(find $DIRS -type d|wc -l)
        DIRS_NF=$(find $DIRS -type f|wc -l)
        echo "* $DIRS_SZ, $DIRS_ND directories, $DIRS_NF files."
    fi
}

start_logging()
{
    [ -d $(dirname $LOGFILE) ] || mkdir -p $(dirname $LOGFILE)
    if [ $VERBOSE -ge 1 ]; then
        exec > >(tee -a $LOGFILE ) 2>&1
    else
        exec >> $LOGFILE 2>&1
    fi
}

tryborg()
{
    local SEC_STARTING=0
    local SEC_DOING=0

    syslog Starting "'$BORG $1'"
    SEC_STARTING=$SECONDS
    while : ; do
        # Wait for the repository to show up
        while ! [ -f $REPOSITORY/README ]; do
            sleep $TRY_WAIT
        done

        # Do action
        syslog Doing "'$BORG $1'"
        SEC_DOING=$SECONDS
        doit $BORG "$@"

        # Action successful - exit
        [ $? -eq 0 ] && break

        # Action failed - Wait then retry
        syslog Failed "'$BORG $1'"
        sleep $TRY_WAIT
    done

    touch $BORG_LASTSUCCESSFUL.$1
    syslog Done "'$BORG $1'" "(total $((SECONDS-SEC_STARTING))s, real $((SECONDS-SEC_DOING))s)"
}

borg_init()
{
    echo "Init borg repository $REPOSITORY"
    doit $BORG init -e none $REPOSITORY
}

borg_create()
{
    tryborg create -v --stats -x --compression lz4  \
        $REPOSITORY::'{hostname}-{now:%Y-%m-%d_%H%M}'    \
        $DIRS                                            \
        $EXCLUDES
}

borg_prune()
{
    # Use the `prune` subcommand to maintain 7 daily, 4 weekly and 6 monthly
    # archives of THIS machine. The '{hostname}-' prefix is very important to
    # limit prune's operation to this machine's archives and not apply to
    # other machine's archives also.
    tryborg prune -v --list                         \
        $REPOSITORY --prefix '{hostname}-'               \
        --keep-daily=7 --keep-weekly=4 --keep-monthly=6
}

lock_get()
{
    while ! mkdir $LOCKDIR &> /dev/null; do
        # Lock failed. Check if the other pid is alive
        OTHERPID="$(cat "$PIDFILE")" || die 99 "lock failed, but cannot get other pid."

        if ! kill -0 $OTHERPID &> /dev/null; then
            # lock is stale, remove it and retry
            rm -rf "$LOCKDIR"
        else
            die 99 "Lock failed, '$LOCKDIR' owned by pid $OTHERPID."
        fi
    done

    echo $$ > $PIDFILE
    trap 'trap - INT TERM EXIT; rm -rf "$LOCKDIR"; exit $?' INT TERM EXIT
}

lock_exit()
{
    exit 0
}

main()
{
    # Get the lock
    lock_get

    # Start logging and print a few statistics
    start_logging
    print_log_header
    print_dirs_stats

    # Do the backup
    if ! [ -d $BORG_CACHE_DIR ]; then
        borg_init
    fi
    borg_create
    borg_prune

    # End logging
    print_log_footer

    # Release the lock
    lock_exit
}

# Must be root
check_root

# Read CLI options
read_options "$@"

# Check or perform install
check_or_do_install

# Read and check configuration
read_conf
check_conf

# Run main process (in background by default)
eval "main $BG"



