#! /bin/bash

# Common settings
BASE=borgcronic
LOGFILE=/var/log/$BASE
CONF=/etc/$BASE.conf
LOGROTATE=/etc/logrotate.d/$BASE
LOCKDIR=/var/lock/$BASE
PIDFILE=/var/lock/$BASE/pid
FIFOFILE=/var/run/$BASE.fifo
CRON_DAILY=/etc/cron.daily/$BASE
CRON_D=/etc/cron.d/$BASE
SYSTEMD_SERVICE=/etc/systemd/system/$BASE.service
TRY_WAIT=120               # (seconds) Delay to wait before trying again
LOGGING=

# Borg environment variables (see https://borgbackup.readthedocs.io/en/stable/usage.html)
export BORG_CACHE_DIR=/var/cache/borg
export BORG_KEYS_DIR=/var/lib/borg/keys
export BORG_SECURITY_DIR=/var/lib/borg/security
BORG_LASTSUCCESSFUL=$BORG_CACHE_DIR/$BASE.success

log()
{
    LVL=$1
    shift
    [ -n "$LOGGING" ] || LVL=0
    case "$LVL" in
        0)
            echo "$@"
            ;;
        1)
            echo "# $(date): $@"
            ;;
        2)
            echo "## $@"
            ;;
        *)
            echo "Unknown level '$LVL'"
            ;;
    esac
}

syslog()
{
    [ "$MODE" = daemon -o "$MODE" = summon ] && logger --id=$BASHPID -t $BASE "$@"
    log 1 "$@"
}

die()
{
    CODE=$1
    shift
    >&2 syslog "ERROR -- $@"
    exit $CODE
}

warning()
{
    >&2 syslog "WARNING -- $@"
}

sizeof()
{
    du -sB1 "$@" | awk '{s+=$1} END {printf "%dM (%d)",s/(2**20),s}'
}

installcheck_does_not_exist()
{
    local DESC=$1
    local FILE=$2

    if [ -z "$FORCE" -a -e $FILE ]; then
        warning "Found $DESC file '$FILE', not overwriting (use '-f' to force or '-u' to update)."
        return 1
    fi
    syslog "Installing $DESC file '$FILE'."

    return 0
}

install_logrotate()
{
    if [ -d $(dirname $LOGROTATE) ]; then
        installcheck_does_not_exist "logrotate" $LOGROTATE || return

        cat > $LOGROTATE <<- __END__
			$LOGFILE
			{
			    rotate 4
			    weekly
			    missingok
			    notifempty
			    compress
			    delaycompress
			}
		__END__
        chmod 644 $LOGROTATE
    else
        warning "$(dirname $LOGROTATE) not found. Can't install logrotate script."
    fi
}

install_conf()
{
    installcheck_does_not_exist "config" $CONF || return

    if [ -e $CONF ]; then
        log 0 "Renaming old config file to '$CONF.old'"
        mv $CONF $CONF.old || die 1 "Cannot rename config file to '$CONF.old'."
    fi

    cat > $CONF <<- __END__
		## BORG_REPO - mandatory
		# BORG_REPO=username@remoteserver.com:borg
		# BORG_REPO=/smb/remoteserver/borg
		BORG_REPO=$BORG_REPO

		## DIRS - mandatory
		DIRS='/home'

		## EXCLUDES - optional
		EXCLUDES='--exclude */.cache'
		EXCLUDES+=' --exclude *.nobak'
		EXCLUDES+=' --exclude */xapiandb'
		EXCLUDES+=' --exclude */.thumbnails'
	__END__
    chmod 644 $CONF
}

install_cron_daily()
{
    installcheck_does_not_exist "cron daily job" $CRON_DAILY || return

    cp $0 $CRON_DAILY
    chmod 755 $CRON_DAILY
}

install_crond_d()
{

    installcheck_does_not_exist "cron.d job" $CRON_D || return

    cat > $CRON_D <<- __END__
		SHELL=/bin/sh
		PATH=/sbin:/usr/sbin:/bin:/usr/bin:/usr/local/bin

		# Start $BASE every 6 hours during daylight
		5 11-23/6 * * * root [ -x $CRON_DAILY ] && perl -le 'sleep rand 900' && $CRON_DAILY >/dev/null 2>&1
	__END__
    chmod 644 $CRON_D
}

install_systemd()
{
    installcheck_does_not_exist "systemd service" $SYSTEMD_SERVICE || return

    # Stop service if running
    systemctl is-active $BASE >/dev/null && systemctl stop $BASE

    cat > $SYSTEMD_SERVICE <<- __END__
		[Unit]
		Description=$BASE daemon
		After=network-online.target

		[Service]
		Type=simple

		User=root
		Group=root
		UMask=022

		ExecStart=$CRON_DAILY daemon

		Restart=on-failure

		# Configures the time to wait before service is stopped forcefully.
		TimeoutStopSec=300

		[Install]
		WantedBy=multi-user.target
	__END__
    chmod 644 $SYSTEMD_SERVICE

    systemctl daemon-reload
    systemctl enable $BASE
    systemctl start $BASE
}

print_size_summary()
{
    log 2 "Borg repo: $(sizeof $BORG_REPO)"
    log 2 "Borg cache: $(sizeof $BORG_CACHE_DIR)"
}

check_root()
{
    [ $(whoami) == "root" ] || die 1 "Run this script as root or with sudo"
}

check_install_and_read_conf()
{
    # Check install
    [ -e $CONF ] || die 1 "'$CONF' not found. Did you run the install script '$BASE install <REPOSITORY>'"

    # Read conf
    BORG_REPO=
    DIRS=
    EXCLUDES=
    . $CONF
    export BORG_REPO
    export BORG_CACHE_DIR
    export BORG_KEYS_DIR
    export BORG_SECURITY_DIR

    # Check conf
    [ -n "$BORG_REPO" ] || die 1 "BORG_REPO not defined or empty in '$CONF'."
    [ -n "$DIRS" ]       || die 1 "DIRS not defined or empty in '$CONF'."
}

usage_help()
{
    cat <<- __END__
Usage: $BASE [-dfhsv] [daemon|exec ...|install REPOSITORY|last|update|summon]

$BASE only runs as root user, or using sudo.

The modes are:

    daemon  DAEMON mode.
            $BASE waits for summon signal. This signal triggers a backup.
    exec ...
            EXEC mode.
            Run borg, passing the remaining parameters on the line
            to borg. This is handy to run borg using $BASE configuration.
    install REPOSITORY
            INSTALL mode.
            Install $BASE, configuration and script files, then run
            borg to initialize REPOSITORY. Use -f to force overwriting
            existing files.
    last
            LAST mode.
            Print a summary of last archives found in the repository for each host.
    update  UPDATE mode.
            Same as INSTALL, but does not update configuration.
            Implies flag -f. The configuration file is NOT modified.
    summon  SUMMON mode.
            In this mode, it summons the daemon to trigger a backup.

Without any option, $BASE runs in SUMMON mode.

Flags or options:

    -d      Run borg in dry-run mode (only for DAEMON or EXEC mode).
    -f      Force overwriting existing files in INSTALL mode.
    -h      This help.
    -s      Display statistics on DIRS before starting the backup.
    -v      Increase verbose level.
__END__
}

read_options()
{
    # Parse options
    VERBOSE=0
    DIRS_STAT=
    DRYRUN=
    INSTALL_ARG=
    FORCE=

    local OPTIONS="dfhsv"
    local usage="Usage: $BASE [-$OPTIONS] [daemon|exec ...|install REPOSITORY|last|update|summon]."$'\n'"Type '$BASE -h' for help."
    while getopts "$OPTIONS" flag; do
        case "$flag" in
            d)
                # Enable dry-run
                DRYRUN=true
                ;;
            f)
                # Force flag for install mode
                FORCE=true
                ;;
            h)
                # Display help
                usage_help
                exit 0
                ;;
            s)
                # Display DIRS statistics
                DIRS_STAT=true
                ;;
            v)
                # Increase Verbose level
                VERBOSE=$((VERBOSE+1))
                ;;
            *)
                die 1 "$usage"
                ;;
        esac
    done

    shift $((OPTIND-1))
    MODE=$1
    case "x$MODE" in
        x)
            # summon is the default mode
            MODE=summon
            ;;
        xexec|xlast)
            VERBOSE=1
            ;;
        xinstall)
            INSTALL_ARG=$2
            VERBOSE=1
            ;;
        xdaemon|xsummon)
            ;;
        xupdate)
            FORCE=true
            VERBOSE=1
            ;;
        *)
            die 1 "$usage"
            ;;
    esac
    ((OPTIND++))
}

print_log_header()
{
    log 0 "####################################################################################################"
    syslog "Starting $BASE[$BASHPID]"
}

print_log_footer()
{
    syslog "Ending $BASE[$BASHPID]"
}

doit()
{
    log 1 "## $@"
    print_size_summary
    log 0 "===================================================================================================="
    "$@"
    local RC=$?
    log 0 "===================================================================================================="
    print_size_summary
    return $RC
}

print_dirs_stats()
{
    if [ -n "$DIRS_STAT" ]; then
        DIRS_SZ=$(sizeof $DIRS)
        DIRS_ND=$(find $DIRS -type d|wc -l)
        DIRS_NF=$(find $DIRS -type f|wc -l)
        log 2 "* $DIRS_SZ, $DIRS_ND directories, $DIRS_NF files."
    fi
}

start_logging()
{
    LOGGING=true
    [ -d $(dirname $LOGFILE) ] || mkdir -p $(dirname $LOGFILE)
    if [ $VERBOSE -ge 1 ]; then
        exec > >(tee -a $LOGFILE ) 2>&1
    else
        exec >> $LOGFILE 2>&1
    fi
}

tryborg()
{
    local SEC_STARTING=0
    local SEC_DOING=0

    syslog Starting "'borg $1'"
    SEC_STARTING=$SECONDS
    while : ; do
        # Wait for the repository to show up
        while ! [ -f $BORG_REPO/README ]; do
            sleep $TRY_WAIT
        done

        # Do action
        syslog Doing "'borg $1'"
        SEC_DOING=$SECONDS
        doit borg "$@"

        # If warning - Tell if we got a warning?
        [ $? -eq 1 ] && warning "borg '$1' returned a WARNING code. Please check '$LOGFILE'."

        # If warning or success - Exit
        [ $? -le 1 ] && break

        # If error - Wait then retry
        syslog "Failed 'borg $1'"
        sleep $TRY_WAIT
    done

    touch $BORG_LASTSUCCESSFUL.$1
    syslog Done "'borg $1'" "(total $((SECONDS-SEC_STARTING))s, real $((SECONDS-SEC_DOING))s)"
}

borg_create()
{
    tryborg create ${DRYRUN:+--dry-run} -v --stats -x --compression lz4 \
        ::'{hostname}_{now:%Y%m%d_%H%M}'                                \
        $DIRS                                                           \
        $EXCLUDES
}

borg_prune()
{
    # Use the `prune` subcommand to maintain 7 daily, 4 weekly and 6 monthly
    # archives of THIS machine. The '{hostname}_' prefix is very important to
    # limit prune's operation to this machine's archives and not apply to
    # other machine's archives also.
    tryborg prune ${DRYRUN:+--dry-run} -v --list \
        :: --prefix '{hostname}_'                \
        --keep-daily=7 --keep-weekly=4 --keep-monthly=6
}

lock_get()
{
    while ! mkdir $LOCKDIR &> /dev/null; do
        # Lock failed. Check if the other pid is alive
        OTHERPID="$(cat "$PIDFILE")" || die 99 "lock failed, but cannot get other pid."

        if ! kill -0 $OTHERPID &> /dev/null; then
            # lock is stale, remove it and retry
            # TODO: fix race condition - another script may rm $LOCKDIR && mkdir $LOCKDIR here
            rm -r "$LOCKDIR" || die 99 "lock failed, but cannot rm lockdir"
        else
            die 99 "Lock failed, '$LOCKDIR' owned by pid $OTHERPID."
        fi
    done

    echo $BASHPID > $PIDFILE
    trap 'trap - INT TERM EXIT; syslog "[daemon] exorcized..."; rm -rf "$LOCKDIR"; exit $?' INT TERM EXIT
}

summon_backup()
{
    # Print log header
    print_log_header

    # Print a few statistics
    print_dirs_stats

    borg_create
    borg_prune

    # Print log footer
    print_log_footer
}

mode_daemon()
{
    declare -A IGNORE

    lock_get                                                # Get the lock

    start_logging                                           # Start logging

    rm -f $FIFOFILE                                         # Create our fifo we will listen on
    mkfifo -m 600 $FIFOFILE
    exec 3<>$FIFOFILE                                       # Open in/out FD on fifo...
                                                            # .. so writers are not blocked / SIGPIPE'd
    while : ; do
        if ! read -t 0 R <$FIFOFILE; then                   # If no pending request
            unset IGNORE                                    # ... clear ignore list
            syslog "[daemon] Waiting for minions..."        # ... notify syslog
        fi

        read R <$FIFOFILE                                   # Get next request
        syslog "[daemon] Got '$R' signal."
        [ -z "${IGNORE[$R]}" ] || continue                  # Skip request if in the ignore list

        case "$R" in
            B)
                summon_backup
                ;;
        esac

        IGNORE[$R]=x                                        # Add last request to ignore list
    done

    # Release the lock - On SIGINT / SIGTERM / SIGEXIT
}

mode_exec()
{
    borg ${DRYRUN:+--dry-run} "$@"
}

mode_install()
{
    log 0 "[INSTALL] Installing $BASE."

    BORG_REPO=$INSTALL_ARG
    mkdir -p $BORG_REPO || die 1 "Cannot create repository dir '$BORG_REPO'"

    # Unstall configuration and scripts files
    install_conf
    install_logrotate
    install_cron_daily
    install_crond_d
    install_systemd

    # Read and check configuration
    check_install_and_read_conf

    # Start logging
    start_logging

    doit ${DRYRUN:+echo} borg init -e none :: || die 1 "borg init failed."
}

mode_last()
{
    local out=$(borg list)
    local sep1=$(date +"--- Now -------------------------------------------------------------- _%Y%m%d_%H%M" -d "now")
    local sep2=$(date +"--- yesterday -------------------------------------------------------- _%Y%m%d_%H%M" -d "yesterday")
    local sep3=$(date +"--- 2 days ago ------------------------------------------------------- _%Y%m%d_%H%M" -d "2 days ago")
    local sep4=$(date +"--- 3 days ago ------------------------------------------------------- _%Y%m%d_%H%M" -d "3 days ago")
    local sep5=$(date +"--- last week -------------------------------------------------------- _%Y%m%d_%H%M" -d "last week")

    export LC_ALL=C
    echo "$out"$'\n'"$sep1"$'\n'"$sep2"$'\n'"$sep3"$'\n'"$sep4"$'\n'"$sep5" \
        | sort -r \
        | sort -t_ -u -k1,1 \
        | sort -r -t_ -k2 \
        | sed -r '/^---/{s/_.*//; s/^|$/\n/g; b}; s/\[.*//'
}

mode_update()
{
    log 0 "[UPDATE] Updating $BASE."

    # Update configuration and scripts files
    install_logrotate
    install_cron_daily
    install_crond_d
    install_systemd
}

mode_summon()
{
    # Start logging
    start_logging

    # Summon the daemon
    syslog "Summon the daemon: 'backup!'."
    [ -e $FIFOFILE ] && echo B >$FIFOFILE
}

# Read CLI options
read_options "$@"
shift $((OPTIND-1))

# Must be root
check_root

# Read and check configuration, unless if installing
[ "$MODE" = install ] || check_install_and_read_conf

# TODO: Is current locking sufficient? Do we need more to protect log file access, cache update... ?
case $MODE in
    daemon)
        mode_daemon "$@"
        ;;
    exec)
        mode_exec "$@"
        ;;
    install)
        mode_install "$@"
        ;;
    last)
        mode_last "$@"
        ;;
    update)
        mode_update "$@"
        ;;
    summon)
        mode_summon "$@"
        ;;
esac

